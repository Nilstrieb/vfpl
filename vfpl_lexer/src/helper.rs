use crate::tokens::CondKeyword;
use crate::TokenKind;

pub fn compute_keyword(identifier: &str) -> Option<TokenKind> {
    Some(match identifier {
        "please" => TokenKind::Please,
        "as" => TokenKind::As,
        "initialize" => TokenKind::Initialize,
        "variable" => TokenKind::Variable,
        "end" => TokenKind::End,
        "check" => TokenKind::Check,
        "whether" => TokenKind::Whether,
        "then" => TokenKind::Then,
        "do" => TokenKind::Do,
        "otherwise" => TokenKind::Otherwise,
        "break" => TokenKind::Break,
        "this" => TokenKind::This,
        "create" => TokenKind::Create,
        "function" => TokenKind::Function,
        "call" => TokenKind::Call,
        "and" => TokenKind::And,
        "absent" => TokenKind::Absent,
        "null" => TokenKind::Null,
        "novalue" => TokenKind::NoValue,
        "undefined" => TokenKind::Undefined,
        "true" => TokenKind::True,
        "false" => TokenKind::False,
        "not" => TokenKind::Not,
        "or" => TokenKind::Or,
        "repeat" => TokenKind::Repeat,
        "return" => TokenKind::Return,
        "while" => TokenKind::While,
        "add" => TokenKind::CondKw(CondKeyword::Add),
        "sub" => TokenKind::CondKw(CondKeyword::Sub),
        "mul" => TokenKind::CondKw(CondKeyword::Mul),
        "div" => TokenKind::CondKw(CondKeyword::Div),
        "modulo" => TokenKind::CondKw(CondKeyword::Mod),
        "with" => TokenKind::CondKw(CondKeyword::With),
        "the" => TokenKind::CondKw(CondKeyword::The),
        "value" => TokenKind::CondKw(CondKeyword::Value),
        "of" => TokenKind::CondKw(CondKeyword::Of),
        "set" => TokenKind::CondKw(CondKeyword::Set),
        "to" => TokenKind::CondKw(CondKeyword::To),
        "from" => TokenKind::CondKw(CondKeyword::From),
        "by" => TokenKind::CondKw(CondKeyword::By),
        "take" => TokenKind::CondKw(CondKeyword::Take),
        "out" => TokenKind::CondKw(CondKeyword::Out),
        "parameter" => TokenKind::CondKw(CondKeyword::Parameter),
        "parameters" => TokenKind::CondKw(CondKeyword::Parameters),
        "that" => TokenKind::CondKw(CondKeyword::That),
        "returns" => TokenKind::CondKw(CondKeyword::Returns),
        "no" => TokenKind::CondKw(CondKeyword::No),
        "argument" => TokenKind::CondKw(CondKeyword::Argument),
        "arguments" => TokenKind::CondKw(CondKeyword::Arguments),
        "go" => TokenKind::CondKw(CondKeyword::Go),
        "sleep" => TokenKind::CondKw(CondKeyword::Sleep),
        "does" => TokenKind::CondKw(CondKeyword::Does),
        "has" => TokenKind::CondKw(CondKeyword::Has),
        "is" => TokenKind::CondKw(CondKeyword::Is),
        "have" => TokenKind::CondKw(CondKeyword::Have),
        "greater" => TokenKind::CondKw(CondKeyword::Greater),
        "less" => TokenKind::CondKw(CondKeyword::Less),
        "than" => TokenKind::CondKw(CondKeyword::Than),
        "equal" => TokenKind::CondKw(CondKeyword::Equal),
        _ => return None,
    })
}
